let add1 = {x -> x + 1} in
let double = {x -> x * 2} in
  5 |> add1 |> double ---> $ == 12;

10 |> {x -> x + 5} |> {x -> x * 3} ---> $ == 45;

let add = {x -> {y -> x + y}} in
let multiply = {x -> {y -> x * y}} in
  5 |> add(3) |> multiply(2) ---> $ == 16;

let square = {x -> x * x} in
(3 + 2) |> square |> {x -> x - 1} ---> $ == 24;

let add1 = {x -> x + 1} in
let double = {x -> x * 2} in
let composed = add1 >> double in
  composed(5) ---> $ == 12;

let add1 = _+1,
    double =_*2,
    subtract3 = _-3 in
let pipeline = add1 >> double >> subtract3 in
  pipeline(10) ---> $ == 19;

let f = {x -> x + 5} >> {x -> x * 3} in f(2) ---> $ == 21;

let add1 = {x -> x + 1} in
let double = {x -> x * 2} in
let square = {x -> x * x} in
let composed = add1 >> double in
  5 |> composed |> square ---> $ == 144;

let increment = {x -> x + 1} in
let double = {x -> x * 2} in
let triple = {x -> x * 3} in
  10 |> increment >> double |> triple ---> $ == 66;

let f1 = {x -> x + 2} in
let f2 = _*3 in
let f3 = _-1 in
let f4 = {x -> x / 2} in
  8 |> f1 >> f2 |> f3 >> f4 ---> $ == 14.5;

let applyTwice = {f -> {x -> f(f(x))}} in
let add3 = {x -> x + 3} in
  5 |> applyTwice(add3) ---> $ == 11;

let makeAdder = {n -> {x -> x + n}} in
let makeMultiplier = {n -> {x -> x * n}} in
let pipeline = makeAdder(5) >> makeMultiplier(2) in
  10 |> pipeline ---> $ == 30;

let add = {x -> {y -> x + y}} in
let multiply = {x -> {y -> x * y}} in
let process = add(10) >> multiply(3) in
  5 |> process ---> $ == 45;

let conditionalOp = {x -> if x > 5 then x * 2 else x + 10} in
let add5 = {x -> x + 5} in
let pipeline = conditionalOp >> add5 in
  3 |> pipeline ---> $ == 18;

let outer = {f -> {g -> {x -> f(g(x))}}} in
let add2 = {x -> x + 2} in
let triple = {x -> x * 3} in
let composed = outer(triple)(add2) in
  4 |> composed ---> $ == 18;

let fib = {n ->
  if n <= 1 then n
  else fib(n - 1) + fib(n - 2)
} in
let double = {x -> x * 2} in
let pipeline = fib >> double in
  10 |> pipeline ---> $ == 110;

let f1 = {x -> x + 1} in
let f2 = {x -> x * 2} in
let f3 = {x -> x - 3} in
let f4 = {x -> x / 4} in
let f5 = {x -> x + 10} in
let bigPipeline = f1 >> f2 >> f3 >> f4 >> f5 in
  20 |> bigPipeline ---> $ == 19.75;

let applyFunction = {f, x -> f(x)} in
let add5 = {x -> x + 5} in
let multiply3 = {x -> x * 3} in
  applyFunction(add5 >> multiply3, 10) ---> $ == 45;

let createProcessor = {op ->
  if op == 1 then {x -> x * 2}
  else if op == 2 then {x -> x + 10}
  else {x -> x}
} in
let pipeline = createProcessor(1) >> createProcessor(2) in
  8 |> pipeline ---> $ == 26;

let churchToInt = {n -> n({x -> x + 1})(0)} in
let zero = {f -> {x -> x}} in
let succ = {n -> {f -> {x -> f(n(f)(x))}}} in
let double = {x -> x * 2} in
let three = succ(succ(succ(zero))) in
  three |> churchToInt >> double ---> $ == 6;

let identity = {x -> x} in
let add1 = {x -> x + 1} in
let chain = identity >> identity >> identity >> add1 >> identity in
  42 |> chain ---> $ == 43;

let selfCompose = {f -> f >> f} in
let add2 = {x -> x + 2} in
let doubleAdd2 = selfCompose(add2) in
  5 |> doubleAdd2 ---> $ == 9;

let _x = 100 in
let _compose_x_123456 = 200 in
let add1 = {x -> x + 1} in
let double = {x -> x * 2} in
let composed = add1 >> double in
  composed(5) + _x + _compose_x_123456 ---> $ == 312;

let x = 50 in
let f = {y -> y + x} in
let g = {z -> z * 2} in
let h = {w -> w - 10} in
let comp1 = f >> g in
let comp2 = g >> h in
let comp3 = comp1 >> comp2 in
  comp3(5) ---> $ == 210;

let makeAdder = {n -> {x -> x + n}} in
let makeMultiplier = {m -> {y -> y * m}} in
  (makeAdder(3) >> makeMultiplier(4))(5) ---> $ == 32;

let solo = {x -> x + 42} in
let composed = solo in
  composed(8) ---> $ == 50;

let identity = {x -> x} in
let add5 = {x -> x + 5} in
let comp1 = identity >> add5 in
let comp2 = add5 >> identity in
let comp3 = identity >> identity >> add5 >> identity in
  comp1(10) + comp2(10) + comp3(10) ---> $ == 45;

let increment = {x -> x + 1} in
let square = {x -> x * x} in
let sqrt = {x -> x^0.5} in
let pipeline = increment >> square >> sqrt in
  pipeline(8) ---> $ == 9;

let isPositive = {x -> x > 0} in
let not_op = {b -> !b} in
let isNonPositive = isPositive >> not_op in
  if isNonPositive(-5) then 1 else 0 ---> $ == 1;

let base = 100 in
let makeAdder = {n ->
  let localBase = base + n in
    {x -> x + localBase}
} in
let makeMult = {m -> {y -> y * m}} in
let comp = makeAdder(5) >> makeMult(2) in
  comp(10) ---> $ == 230;

let factorial = {n ->
  if n <= 1 then 1
  else n * factorial(n - 1)
} in
let double = {x -> x * 2} in
let comp = factorial >> double in
  comp(4) ---> $ == 48;

let applyTwice = {f -> {x -> f(f(x))}} in
let add3 = {x -> x + 3} in
let comp = applyTwice >> {f -> f(10)} in
  comp(add3) ---> $ == 16;

let makePowerOf = {n -> {x -> x^n}} in
let makeAdderOf = {n -> {x -> x + n}} in
let comp = makePowerOf(2) >> makeAdderOf(1) in
  comp(5) ---> $ == 26;

let id = {x -> x} in
let add1 = _+1 in
let longChain = id >> id >> id >> add1 >> id >> id >> id >> add1 >> id >> add1 in
  longChain(0) ---> $ == 3;

let add1 = _+1 in
let sub1 = _-1 in
let alternating = add1 >> sub1 >> add1 >> sub1 >> add1 >> sub1 >> add1 in
  alternating(10) ---> $ == 11;


let conditionalFunc = {x -> if x > 5 then x * 2 else x + 10} in
let add1 = {x -> x + 1} in
let comp = conditionalFunc >> (add1) in
  comp(3) + comp(7) ---> $ == 29;

let divideBy = {n -> {x -> x / n}} in
let addTen = {x -> x + 10} in
let comp = divideBy(2) >> addTen in
  comp(20) ---> $ == 20;


[1, 2, ...[3, 4]] ---> $ == [1, 2, 3, 4];

[...[], 1, 2] ---> $ == [1, 2];

[1, ...[], 2] ---> $ == [1, 2];

[...[], ...[]] ---> $ == [];

[...[1, 2], 3, 4] ---> $ == [1, 2, 3, 4];

let x = [5, 6] in [1, ...x, 2] ---> $ == [1, 5, 6, 2];

[...[1 + 2, 3 * 4], 100] ---> $ == [3, 12, 100];

[[... [1, 2]], [... [3, 4]]] ---> $ == [[1, 2], [3, 4]];

[...[...[1, 2], ...[3, 4]]] ---> $ == [1, 2, 3, 4];

let f = {x -> x} in [...f([1, 2])] ---> $ == [1, 2];

[...[...[...[]]]] ---> $ == [];

{x,y,...args->args}(1,2,3,4,5) ---> $ == [3, 4, 5];

let args = [64, 2] in
  log(...args) ---> $ == 6

let sum = {...numbers ->
  let helper = {nums, acc ->
    if length(nums) == 0 then acc
    else helper(slice(nums, 1, -1), acc + nums[0])
  } in helper(numbers, 0)
} in
  sum(1, 2, 3, 4, 5) ---> $ == 15

let normalizeText = {text ->
  text
  |> List
  |> filter(_, {c -> c != " " || true})
  |> join(_, "")
  |> {s -> split(s, " ")}
  |> filter(_, {word -> length(word) > 0})
  |> join(_, " ")
} in
normalizeText("  hello    world   test  ") ---> $ == "hello world test";
