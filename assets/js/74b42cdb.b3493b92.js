"use strict";(self.webpackChunknumfu_docs=self.webpackChunknumfu_docs||[]).push([[555],{8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var i=s(6540);const t={},l=i.createContext(t);function a(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(l.Provider,{value:n},e.children)}},9562:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guide/lists","title":"Lists","description":"Lists are NumFu\'s primary data structure for working with collections of values. They\'re immutable, heterogeneous (can contain different types), and come with powerful operations for transformation and manipulation.","source":"@site/../docs/guide/lists.md","sourceDirName":"guide","slug":"/guide/lists","permalink":"/docs/guide/lists","draft":false,"unlisted":false,"editUrl":"https://github.com/rphle/numfu/tree/main/docs/../docs/guide/lists.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Functions","permalink":"/docs/guide/functions"},"next":{"title":"Strings and Text","permalink":"/docs/guide/strings"}}');var t=s(4848),l=s(8453);const a={},r="Lists",c={},d=[{value:"Creating Lists",id:"creating-lists",level:2},{value:"List Literals",id:"list-literals",level:3},{value:"Nested Lists",id:"nested-lists",level:3},{value:"Lists with Expressions",id:"lists-with-expressions",level:3},{value:"Accessing List Elements",id:"accessing-list-elements",level:2},{value:"Indexing",id:"indexing",level:3},{value:"Negative Indexing",id:"negative-indexing",level:3},{value:"Nested List Access",id:"nested-list-access",level:3},{value:"Index Bounds",id:"index-bounds",level:3},{value:"List Operations",id:"list-operations",level:2},{value:"Concatenation",id:"concatenation",level:3},{value:"Repetition",id:"repetition",level:3},{value:"List Equality",id:"list-equality",level:3},{value:"Built-in List Functions",id:"built-in-list-functions",level:2},{value:"Length",id:"length",level:3},{value:"Adding Elements",id:"adding-elements",level:3},{value:"Element Testing",id:"element-testing",level:3},{value:"List Transformation",id:"list-transformation",level:3},{value:"Sorting",id:"sorting",level:3},{value:"Slicing",id:"slicing",level:3},{value:"Setting Elements",id:"setting-elements",level:3},{value:"Functional List Operations",id:"functional-list-operations",level:2},{value:"<code>map</code> - Transform Every Element",id:"map---transform-every-element",level:3},{value:"<code>filter</code> - Select Elements",id:"filter---select-elements",level:3},{value:"Examples",id:"examples",level:2},{value:"List Comprehension Style",id:"list-comprehension-style",level:3},{value:"Matrix Operations",id:"matrix-operations",level:3},{value:"Sum each row in a matrix",id:"sum-each-row-in-a-matrix",level:4},{value:"Flatten a matrix",id:"flatten-a-matrix",level:4},{value:"Transpose a matrix",id:"transpose-a-matrix",level:4},{value:"Statistics",id:"statistics",level:3},{value:"Calculate mean of a list",id:"calculate-mean-of-a-list",level:4},{value:"Safe List Access",id:"safe-list-access",level:3},{value:"List Validation",id:"list-validation",level:3},{value:"List Reduction",id:"list-reduction",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"lists",children:"Lists"})}),"\n",(0,t.jsx)(n.p,{children:"Lists are NumFu's primary data structure for working with collections of values. They're immutable, heterogeneous (can contain different types), and come with powerful operations for transformation and manipulation."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"creating-lists",children:"Creating Lists"}),"\n",(0,t.jsx)(n.h3,{id:"list-literals",children:"List Literals"}),"\n",(0,t.jsx)(n.p,{children:"Create lists using square brackets with comma-separated elements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'[];                             // Empty list\n[1, 2, 3];                      // Numbers\n["hello", "world"];             // Strings\n[true, false, true];            // Booleans\n[1, "hello", true];             // Mixed types\n'})}),"\n",(0,t.jsx)(n.h3,{id:"nested-lists",children:"Nested Lists"}),"\n",(0,t.jsx)(n.p,{children:"Lists can contain other lists:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"[[1, 2], [3, 4]];               // 2D list\n[[], [1], [1, 2]];              // Lists of different lengths\n[[[1]], [[2, 3]], [[4, 5, 6]]]; // 3D nested structure\n"})}),"\n",(0,t.jsx)(n.h3,{id:"lists-with-expressions",children:"Lists with Expressions"}),"\n",(0,t.jsx)(n.p,{children:"List elements can be any expressions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"[1 + 2, 3 * 4, 5^2];            // [3, 12, 25]\n[sin(0), cos(0), tan(0)];       // [0, 1, 0]\n\nlet x = 10 in [x, x*2, x*3];    // [10, 20, 30]\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"accessing-list-elements",children:"Accessing List Elements"}),"\n",(0,t.jsx)(n.h3,{id:"indexing",children:"Indexing"}),"\n",(0,t.jsx)(n.p,{children:"Access elements using square bracket notation (0-based indexing):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'let fruits = ["apple", "banana", "cherry"] in\n  fruits[0];    // "apple"\n  // or...\n  fruits[1];    // "banana"\n  fruits[2];    // "cherry"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"negative-indexing",children:"Negative Indexing"}),"\n",(0,t.jsx)(n.p,{children:"Access elements from the end using negative indices:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let numbers = [10, 20, 30, 40, 50] in\n  numbers[-1];    // 50 (last element)\n  // or...\n  numbers[-2];    // 40 (second to last)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"nested-list-access",children:"Nested List Access"}),"\n",(0,t.jsx)(n.p,{children:"Access nested lists by chaining indices:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] in\n  matrix[1][2];    // 6 (row 1, column 2)\n  // or...\n  matrix[0][0];    // 1 (top-left)\n  matrix[2][2];    // 9 (bottom-right)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"index-bounds",children:"Index Bounds"}),"\n",(0,t.jsx)(n.p,{children:"Accessing out-of-bounds indices raises an error:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let short = [1, 2] in\n  short[5]\n// IndexError: List index out of range\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"list-operations",children:"List Operations"}),"\n",(0,t.jsx)(n.h3,{id:"concatenation",children:"Concatenation"}),"\n",(0,t.jsxs)(n.p,{children:["Combine lists using the ",(0,t.jsx)(n.code,{children:"+"})," operator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'[1, 2] + [3, 4];                // [1, 2, 3, 4]\n["a"] + ["b", "c"] + ["d"];     // ["a", "b", "c", "d"]\n[] + [1, 2, 3];                 // [1, 2, 3]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"repetition",children:"Repetition"}),"\n",(0,t.jsxs)(n.p,{children:["Repeat lists using the ",(0,t.jsx)(n.code,{children:"*"})," operator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'[1, 2] * 3;                     // [1, 2, 1, 2, 1, 2]\n["hello"] * 2;                  // ["hello", "hello"]\n[1, 2, 3] * 0;                  // []\n'})}),"\n",(0,t.jsx)(n.h3,{id:"list-equality",children:"List Equality"}),"\n",(0,t.jsx)(n.p,{children:"Compare lists for equality:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"[1, 2, 3] == [1, 2, 3];         // true\n[1, 2] == [2, 1];               // false (order matters)\n[] == [];                       // true\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"built-in-list-functions",children:"Built-in List Functions"}),"\n",(0,t.jsxs)(n.p,{children:["All of these functions must be imported from the ",(0,t.jsx)(n.code,{children:"std"})," standard library module. When running the examples below, remember to import it at the top of your file (or in the REPL):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'import * from "std"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"length",children:"Length"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"length([1, 2, 3, 4]);           // 4\nlength([]);                     // 0\n"})}),"\n",(0,t.jsx)(n.h3,{id:"adding-elements",children:"Adding Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'[1, 2, 3] + [4]                 // [1, 2, 3, 4]\nappend([1, 2, 3], 4);           // [1, 2, 3, 4]\nappend([], "first");            // ["first"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"element-testing",children:"Element Testing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'contains([1, 2, 3], 2);           // true\ncontains(["a", "b", "c"], "x");   // false\ncontains([[], [1], [2]], []);     // true\n'})}),"\n",(0,t.jsx)(n.h3,{id:"list-transformation",children:"List Transformation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'reverse([1, 2, 3, 4]);          // [4, 3, 2, 1]\nreverse([]);                    // []\nreverse(["a", "b", "c"]);       // ["c", "b", "a"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"sorting",children:"Sorting"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'sort([3, 1, 4, 1, 5]);                // [1, 1, 3, 4, 5]\nsort(["banana", "apple", "cherry"]);  // ["apple", "banana", "cherry"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"slicing",children:"Slicing"}),"\n",(0,t.jsxs)(n.p,{children:["Extract sublists using ",(0,t.jsx)(n.code,{children:"slice(list, start, end)"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"slice([1, 2, 3, 4, 5], 1, 3);   // [2, 3, 4] (inclusive end)\nslice([1, 2, 3, 4, 5], 0, 2);   // [1, 2, 3]\nslice([1, 2, 3, 4, 5], 2, -2);  // [3, 4] (negative index)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setting-elements",children:"Setting Elements"}),"\n",(0,t.jsx)(n.p,{children:"Create new lists with modified elements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'set([1, 2, 3], 1, 99);          // [1, 99, 3]\nset(["a", "b", "c"], 0, "X");   // ["X", "b", "c"]\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"functional-list-operations",children:"Functional List Operations"}),"\n",(0,t.jsxs)(n.h3,{id:"map---transform-every-element",children:[(0,t.jsx)(n.code,{children:"map"})," - Transform Every Element"]}),"\n",(0,t.jsx)(n.p,{children:"Apply a function to every element in a list:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let numbers = [1, 2, 3, 4, 5] in\nlet squares = map(numbers, {x -> x * x}) in\n  squares    // [1, 4, 9, 16, 25]\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"filter---select-elements",children:[(0,t.jsx)(n.code,{children:"filter"})," - Select Elements"]}),"\n",(0,t.jsx)(n.p,{children:"Keep only elements that satisfy a condition:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] in\nlet evens = filter(numbers, {x -> x % 2 == 0}) in\n  evens    // [2, 4, 6, 8, 10]\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsxs)(n.p,{children:["When running the examples below, remember to import the ",(0,t.jsx)(n.code,{children:"std"})," standard library module at the top of your file (or in the REPL) because it provides essential functions for working with lists."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:'import * from "std"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"list-comprehension-style",children:"List Comprehension Style"}),"\n",(0,t.jsx)(n.p,{children:"While NumFu doesn't have list comprehensions, you can simulate them:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"// Generate even squares of numbers 1-10\nlet range = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] in\n  filter(map(range, {x -> x * x}), {x -> x % 2 == 0})\n// [4, 16, 36, 64, 100]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"matrix-operations",children:"Matrix Operations"}),"\n",(0,t.jsx)(n.h4,{id:"sum-each-row-in-a-matrix",children:"Sum each row in a matrix"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] in\n  map(matrix, {row ->\n    let sum = {lst ->\n      if length(lst) == 0 then 0\n      else lst[0] + sum(slice(lst, 1, -1))\n    } in sum(row)\n  })\n// [6, 15, 24]\n"})}),"\n",(0,t.jsx)(n.h4,{id:"flatten-a-matrix",children:"Flatten a matrix"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let flatten = {lists ->\n  if length(lists) == 0 then []\n  else lists[0] + flatten(slice(lists, 1, -1))\n} in\nflatten([[1, 2], [3, 4], [5, 6]])\n// [1, 2, 3, 4, 5, 6]\n"})}),"\n",(0,t.jsx)(n.h4,{id:"transpose-a-matrix",children:"Transpose a matrix"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let transpose = {matrix ->\n  if length(matrix) == 0 then []\n  else\n    let numCols = length(matrix[0]) in\n    let getColumn = {col ->\n      map(matrix, {row -> row[col]})\n    } in\n    let range = [0, 1, 2] in  // Assuming 3x3 matrix\n      map(range, getColumn)\n} in\ntranspose([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n// [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"statistics",children:"Statistics"}),"\n",(0,t.jsx)(n.h4,{id:"calculate-mean-of-a-list",children:"Calculate mean of a list"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let mean = {numbers ->\n  let sum = {lst ->\n    if length(lst) == 0 then 0\n    else lst[0] + sum(slice(lst, 1, -1))\n  } in\n  sum(numbers) / length(numbers)\n} in\n  mean([10, 20, 30, 40, 50])            // 30\n"})}),"\n",(0,t.jsx)(n.h3,{id:"safe-list-access",children:"Safe List Access"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"// Safe indexing with default values\nlet safeGet = {lst, index, default ->\n  if index >= 0 && index < length(lst) then lst[index]\n  else default\n};\nsafeGet([1, 2, 3], 5, 0);             // 0 (default)\nsafeGet([1, 2, 3], 1, 0);             // 2 (actual value)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"list-validation",children:"List Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"// Check if all elements satisfy a condition\nlet allPositive = {numbers ->\n  length(filter(numbers, {x -> x > 0})) == length(numbers)\n};\nallPositive([1, 2, 3, 4]);            // true\nallPositive([1, -2, 3, 4]);           // false\n"})}),"\n",(0,t.jsx)(n.h3,{id:"list-reduction",children:"List Reduction"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-numfu",children:"let reduce = {lst, fn, initial ->\n  if length(lst) == 0 then initial\n  else reduce(slice(lst, 1, -1), fn, fn(initial, lst[0]))\n};\nreduce([1, 2, 3, 4], {acc, x -> acc + x}, 0);  // 10\nreduce([1, 2, 3, 4], {acc, x -> acc * x}, 1);  // 24\n"})})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);