"use strict";(self.webpackChunknumfu_docs=self.webpackChunknumfu_docs||[]).push([[234],{8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>t});var s=i(6540);const r={},o=s.createContext(r);function l(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(o.Provider,{value:n},e.children)}},9721:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"guide/operators","title":"Special Operators","description":"NumFu includes several expressive operators to make functional programming more intuitive:","source":"@site/../docs/guide/operators.md","sourceDirName":"guide","slug":"/guide/operators","permalink":"/numfu/docs/guide/operators","draft":false,"unlisted":false,"editUrl":"https://github.com/rphle/numfu/tree/main/docs/../docs/guide/operators.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Strings and Text","permalink":"/numfu/docs/guide/strings"},"next":{"title":"Partial Application","permalink":"/numfu/docs/guide/partial-application"}}');var r=i(4848),o=i(8453);const l={},t="Special Operators",a={},c=[{value:"Function Composition (<code>&gt;&gt;</code>)",id:"function-composition-",level:2},{value:"Piping (<code>|&gt;</code>)",id:"piping-",level:2},{value:"Composition vs Piping",id:"composition-vs-piping",level:2},{value:"Currying + Composition",id:"currying--composition",level:2},{value:"Spread Operator (<code>...</code>)",id:"spread-operator-",level:2},{value:"List Spreading",id:"list-spreading",level:3},{value:"Spread in Function Calls and Parameters",id:"spread-in-function-calls-and-parameters",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"special-operators",children:"Special Operators"})}),"\n",(0,r.jsx)(n.p,{children:"NumFu includes several expressive operators to make functional programming more intuitive:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:">>"})," for ",(0,r.jsx)(n.strong,{children:"function composition"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"|>"})," for ",(0,r.jsx)(n.strong,{children:"data piping"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"..."})," for ",(0,r.jsx)(n.strong,{children:"list spreading and rest arguments"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h2,{id:"function-composition-",children:["Function Composition (",(0,r.jsx)(n.code,{children:">>"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Function composition lets you build new functions by chaining simpler ones together."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:"let add1 = {x -> x + 1} in\nlet double = {x -> x * 2} in\nlet add1ThenDouble = add1 >> double in\n  add1ThenDouble(5)           // 12  ((5 + 1) * 2)\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can chain as many functions as needed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:'import * from "std"\n\nlet capitalize = {s -> toUpperCase(s[0]) + slice(s, 1, -1)} in\nlet clean = trim >> toLowerCase >> capitalize in\n  clean("  HELLO WORLD  ")    // "Hello World"\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h2,{id:"piping-",children:["Piping (",(0,r.jsx)(n.code,{children:"|>"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Piping is about applying a series of functions to a value. It passes the result of one expression as argument to the next function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:"5 |> {x -> x + 1} |> {x -> x * 2}   // 12\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is equivalent to:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:"{ x -> x * 2 }({ x -> x + 1 }(5))\n"})}),"\n",(0,r.jsx)(n.p,{children:"Piping makes data processing chains more readable and expressive"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:'import format from "std"\n\nlet isEven = {x -> x % 2 == 0} in\nlet double = {x -> x * 2} in\nlet halve = {x -> x / 2} in\n  6 |> {x -> if isEven(x) then double(x) else halve(x)}\n  |> {x -> format("Result: {}", x)}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Result: 12\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"composition-vs-piping",children:"Composition vs Piping"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Function Composition (",(0,r.jsx)(n.code,{children:">>"}),")"]})," creates a ",(0,r.jsx)(n.em,{children:"new"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:"let f = {x -> x + 1} >> {x -> x * 2} in\nf(5)    // 12\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Piping (",(0,r.jsx)(n.code,{children:"|>"}),")"]})," applies functions ",(0,r.jsx)(n.em,{children:"immediately"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:"5 |> {x -> x + 1} |> {x -> x * 2}    // 12\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"currying--composition",children:"Currying + Composition"}),"\n",(0,r.jsx)(n.p,{children:"Currying lets you fix arguments before composing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:"let add = {x, y -> x + y} in\nlet multiply = {x, y -> x * y} in\n\nlet pipeline = add(10) >> multiply(2) in\npipeline(5)                  // 30  ((5 + 10) * 2)\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h2,{id:"spread-operator-",children:["Spread Operator (",(0,r.jsx)(n.code,{children:"..."}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["The spread operator unpacks list elements or ",(0,r.jsx)(n.a,{href:"http://localhost:3000/docs/guide/functions#collecting-extra-arguments",children:"collects extra arguments"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"list-spreading",children:"List Spreading"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"..."})," inside lists to insert the contents of other lists:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:"[1, ...[2, 3], 4];            // [1, 2, 3, 4]\n[...[1, 2], ...[3, 4]];       // [1, 2, 3, 4]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Spreading is especially useful when combining multiple variables:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:"let a = [1, 2], b = [3, 4], c = [5, 6] in\n  [0, ...a, ...b, ...c, 7]   // [0, 1, 2, 3, 4, 5, 6, 7]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Empty lists are ignored when spread:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:"[1, ...[], 2];                // [1, 2]\n[...[], ...[]];               // []\n"})}),"\n",(0,r.jsx)(n.h3,{id:"spread-in-function-calls-and-parameters",children:"Spread in Function Calls and Parameters"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"..."})," can be used to collect or expand arguments in functions."]}),"\n",(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.em,{children:"collecting"})," arguments, ",(0,r.jsx)(n.a,{href:"functions#rest-parameters",children:"see here"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["As within lists, you can use the spread operator inside function calls to ",(0,r.jsx)(n.em,{children:"expand"})," arguments:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-numfu",children:'import log from "math"\n\nlet args = [64, 2] in\n  log(...args)    // same as log(64, 2) -> 6\n'})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);