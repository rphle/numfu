"use strict";(self.webpackChunknumfu_docs=self.webpackChunknumfu_docs||[]).push([[550],{3708:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>l,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"guide/functions","title":"Functions","description":"As a functional programming language, NumFu treats functions as first-class values that can be created, passed around, and composed to build complex programs from simple parts.","source":"@site/../docs/guide/functions.md","sourceDirName":"guide","slug":"/guide/functions","permalink":"/numfu/docs/guide/functions","draft":false,"unlisted":false,"editUrl":"https://github.com/rphle/numfu/tree/main/docs/../docs/guide/functions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Variables and Let Expressions","permalink":"/numfu/docs/guide/variables"},"next":{"title":"Lists","permalink":"/numfu/docs/guide/lists"}}');var s=i(4848),a=i(8453);const l={},c="Functions",r={},u=[{value:"Function Basics",id:"function-basics",level:2},{value:"Creating Simple Functions",id:"creating-simple-functions",level:3},{value:"Calling Functions",id:"calling-functions",level:3},{value:"Inline Function Calls",id:"inline-function-calls",level:3},{value:"Multiple Parameters",id:"multiple-parameters",level:2},{value:"Multiple Arguments",id:"multiple-arguments",level:3},{value:"Recursive Functions",id:"recursive-functions",level:2},{value:"Tail Call Optimization",id:"tail-call-optimization",level:3},{value:"Rest Parameters",id:"rest-parameters",level:2},{value:"Collecting Extra Arguments",id:"collecting-extra-arguments",level:3},{value:"Example",id:"example",level:3},{value:"Higher-Order Functions",id:"higher-order-functions",level:2},{value:"Functions That Accept Functions",id:"functions-that-accept-functions",level:3},{value:"Functions That Return Functions",id:"functions-that-return-functions",level:3},{value:"Function Factories",id:"function-factories",level:3},{value:"Closures",id:"closures",level:2},{value:"Capturing Environment",id:"capturing-environment",level:3},{value:"Closures Preserve Values",id:"closures-preserve-values",level:3},{value:"Examples",id:"examples",level:2},{value:"Configurable Greeting",id:"configurable-greeting",level:3},{value:"Conditional Function Selection",id:"conditional-function-selection",level:3},{value:"Mathematical Functions",id:"mathematical-functions",level:3},{value:"Function Composition Function",id:"function-composition-function",level:3},{value:"Higher-Order Functions",id:"higher-order-functions-1",level:3},{value:"Recursive Functions",id:"recursive-functions-1",level:3}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"functions",children:"Functions"})}),"\n",(0,s.jsx)(n.p,{children:"As a functional programming language, NumFu treats functions as first-class values that can be created, passed around, and composed to build complex programs from simple parts."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"function-basics",children:"Function Basics"}),"\n",(0,s.jsx)(n.h3,{id:"creating-simple-functions",children:"Creating Simple Functions"}),"\n",(0,s.jsxs)(n.p,{children:["In NumFu, functions are created using lambda expressions with the syntax ",(0,s.jsx)(n.code,{children:"{parameters -> body}"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:'{x -> x + 1}                    // Function that adds 1\n{x -> x * x}                    // Function that squares a number\n{name -> "Hello, " + name}      // Function that creates a greeting\n'})}),"\n",(0,s.jsx)(n.h3,{id:"calling-functions",children:"Calling Functions"}),"\n",(0,s.jsx)(n.p,{children:"Call functions using parentheses:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:'let square = {x -> x * x} in square(5)     // 25\nlet greet = {name -> "Hello, " + name} in greet("NumFu")  // "Hello, NumFu"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"inline-function-calls",children:"Inline Function Calls"}),"\n",(0,s.jsx)(n.p,{children:"You can call lambda expressions directly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"{x -> x + 1}(10)               // 11\n{x, y -> x * y}(3, 4)          // 12\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"multiple-parameters",children:"Multiple Parameters"}),"\n",(0,s.jsx)(n.h3,{id:"multiple-arguments",children:"Multiple Arguments"}),"\n",(0,s.jsx)(n.p,{children:"Functions can accept multiple parameters separated by commas:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"{x, y -> x + y}                // Addition function\n{a, b, c -> a * b + c}         // Linear function\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:'let say = {name, age -> format("{} is {} years old", name, age)} in\n  say("John", 42)\n// John is 42 years old\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"recursive-functions",children:"Recursive Functions"}),"\n",(0,s.jsx)(n.p,{children:"Named functions can call themselves recursively:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"let fibonacci = {n ->\n  if n <= 1 then n\n  else fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nfibonacci(10)    // 55\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can control the maximum recursion depth using the CLI argument ",(0,s.jsx)(n.code,{children:"--rec-depth"})," (",(0,s.jsx)(n.a,{href:"/docs/reference/cli#numfu-file-default-command",children:"see CLI reference"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"tail-call-optimization",children:"Tail Call Optimization"}),"\n",(0,s.jsx)(n.p,{children:"NumFu automatically optimizes tail-recursive function calls, allowing you to write recursive algorithms without running into stack overflow or performance issues."}),"\n",(0,s.jsx)(n.p,{children:'A function call is in "tail position" when it\'s the last operation before returning. NumFu can optimize these calls to use constant memory instead of growing the call stack:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"// Tail-recursive factorial (optimized)\nlet factorial = {n, acc ->\n  if n <= 0 then acc\n  else factorial(n - 1, acc * n)\n}\n\n// Non tail-recursive factorial (not optimized)\nlet factorial_slow = {n ->\n  if n <= 0 then 1\n  else n * factorial_slow(n - 1)  // multiplication happens after the call\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The tail-recursive version works, but the non-optimized version fails with large values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:">>> factorial(10000, 1); factorial_slow(10000)\n2.84625968091707e+35659\n[at REPL:1:?]\nRecursionError: maximum recursion depth exceeded\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can control the maximum maximum number of tail-call iterations using the CLI argument ",(0,s.jsx)(n.code,{children:"--iter-depth"})," (",(0,s.jsx)(n.a,{href:"/docs/reference/cli#numfu-file-default-command",children:"see CLI reference"}),")."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"rest-parameters",children:"Rest Parameters"}),"\n",(0,s.jsx)(n.h3,{id:"collecting-extra-arguments",children:"Collecting Extra Arguments"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"...paramName"})," to collect remaining arguments into a list:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"{first, ...rest -> [first, rest]}(1, 2, 3, 4, 5)\n// [1, [2, 3, 4, 5]]\n\n{...args -> length(args)}(1, 2, 3)    // 3\n"})}),"\n",(0,s.jsx)(n.p,{children:"Each function can only have a single rest parameter which must come at the end."}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:'import length, slice from "std"\n\nlet sum = {...numbers ->\n  let helper = {nums, acc ->\n    if length(nums) == 0 then acc\n    else helper(slice(nums, 1, -1), acc + nums[0])\n  } in helper(numbers, 0)\n} in\n  sum(1, 2, 3, 4, 5)    // 15\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"higher-order-functions",children:"Higher-Order Functions"}),"\n",(0,s.jsx)(n.h3,{id:"functions-that-accept-functions",children:"Functions That Accept Functions"}),"\n",(0,s.jsx)(n.p,{children:"Functions can take other functions as parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"let twice = {f, x -> f(f(x))} in\nlet add1 = {x -> x + 1} in\n  twice(add1, 5)                // 7 (add1(add1(5)))\n"})}),"\n",(0,s.jsx)(n.h3,{id:"functions-that-return-functions",children:"Functions That Return Functions"}),"\n",(0,s.jsx)(n.p,{children:"Functions can return other functions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"let makeAdder = {n -> {x -> x + n}} in\nlet add10 = makeAdder(10) in\n  add10(5)                      // 15\n"})}),"\n",(0,s.jsx)(n.h3,{id:"function-factories",children:"Function Factories"}),"\n",(0,s.jsx)(n.p,{children:"Create specialized functions using function factories:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"let makePowerFunction = {exponent ->\n  {base -> base ^ exponent}\n} in\nlet square = makePowerFunction(2) in\nlet cube = makePowerFunction(3) in\n  [square(4), cube(3)]    // [16, 27]\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"closures",children:"Closures"}),"\n",(0,s.jsx)(n.h3,{id:"capturing-environment",children:"Capturing Environment"}),"\n",(0,s.jsx)(n.p,{children:"Functions capture variables from their surrounding environment:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"let multiplier = 10 in\nlet scale = {x -> x * multiplier} in\n  scale(5)     50\n"})}),"\n",(0,s.jsx)(n.h3,{id:"closures-preserve-values",children:"Closures Preserve Values"}),"\n",(0,s.jsx)(n.p,{children:"Even when the original scope ends, the captured values remain:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"let makeCounter = {start ->\n  let current = start in\n    {increment -> current + increment}\n} in\nlet counter = makeCounter(100) in\n  counter(5)    // 105\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h3,{id:"configurable-greeting",children:"Configurable Greeting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:'// Create a configurable greeting function\nlet makeGreeting = {greeting, punctuation, name ->\n  greeting + ", " + name + punctuation\n} in\nlet casual = makeGreeting("Hi") in\nlet casualExcited = casual("!") in\n  casualExcited("Alice")        // "Hi, Alice!"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"conditional-function-selection",children:"Conditional Function Selection"}),"\n",(0,s.jsx)(n.p,{children:"Choose functions based on conditions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:'let operation = "square" in\nlet processor = if operation == "square" then {x -> x * x}\n                else if operation == "double" then {x -> x * 2}\n                else {x -> x} in\n  processor(6)    // 36\n'})}),"\n",(0,s.jsx)(n.h3,{id:"mathematical-functions",children:"Mathematical Functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:'import sqrt from "math"\n\n// Distance between two points\nlet distance = {x1, y1, x2, y2 ->\n  let dx = x2 - x1, dy = y2 - y1 in\n    sqrt(dx^2 + dy^2)\n} in\n  distance(0, 0, 3, 4)    // 5\n'})}),"\n",(0,s.jsx)(n.h3,{id:"function-composition-function",children:"Function Composition Function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"// Compose multiple functions\nlet compose = {f, g -> {x -> f(g(x))}} in\n\nlet add1 = {x -> x + 1} in\nlet double = {x -> x * 2} in\n\ncompose(double, add1)(5)    // 12 (double(add1(5)))\n"})}),"\n",(0,s.jsx)(n.h3,{id:"higher-order-functions-1",children:"Higher-Order Functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"// Create a function that applies another function twice\nlet applyTwice = {f, x -> f(f(x))} in\nlet increment = {x -> x + 1} in\n  applyTwice(increment, 10)    // 12\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"// Create a function that creates multiplier functions\nlet makeMultiplier = {factor -> {x -> x * factor}} in\nlet triple = makeMultiplier(3) in\n  triple(7)    // 21\n"})}),"\n",(0,s.jsx)(n.h3,{id:"recursive-functions-1",children:"Recursive Functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"// Factorial function\nlet factorial = {n ->\n  if n <= 1 then 1\n  else n * factorial(n - 1)\n} in\n  factorial(5)    // 120\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-numfu",children:"// Square root using Newton's method\nlet sqrt = {x ->\n  let improve = {guess -> (guess + x / guess) / 2} in\n    let iterate = {guess, n ->\n      if n <= 0 then guess\n      else iterate(improve(guess), n - 1)\n    } in iterate(x / 2, 10)\n} in sqrt(25)    // 5\n"})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>c});var t=i(6540);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);