?start: expr*
?expr: logic_or | pipe_expr
pipe_expr: expr (PIPE call)+ -> pipe_chain

?logic_or: logic_and | logic_or OR logic_and -> bin_op
?logic_and: comp | logic_and AND comp -> bin_op

?comp: arith ( (EQ | NE | LT | GT | LE | GE) arith )*
?arith: term | arith (ADD | SUB) term -> bin_op
?term: factor | term (MUL | DIV | MOD) factor -> bin_op
?factor: power | ADD factor -> pos | SUB factor -> neg | NOT factor -> not_op
?power: call | call POW power -> bin_op

?call: atom | call call_args
call_args: "[" [expr ("," expr)*] "]"

?atom: BOOLEAN       -> boolean
     | NUMBER        -> number
     | NAME          -> variable
     | "(" expr ")"
     | lambda_def
     | conditional
     | let_binding
     | constant_def

lambda_def: "(" (NAME ":")? lambda_params "->" expr ")"
lambda_params: (NAME ("," NAME)*)?
conditional: "if" expr "then" expr "else" expr
let_binding: "let" let_params "in" expr
constant_def: "const" NAME "=" expr
let_params: (NAME "=" expr ("," NAME "=" expr)*)?

ADD: "+"
SUB: "-"
MUL: "*"
DIV: "/"
MOD: "%"
POW: "^"
EQ: "=="
NE: "!="
NOT: "!"
LT: "<"
GT: ">"
LE: "<="
GE: ">="
AND: "&&"
OR: "||"
PIPE: "|>"
BOOLEAN.2: "true" | "false"
NUMBER: /((0|[1-9][\d_]*)(\.[\d_]+)?|\.[\d_]+)([eE][+-]?[\d_]+)?/
NAME.1: /[a-zA-Z_][a-zA-Z0-9_]*/

%import common.WS
%ignore WS
%ignore /\/\/[^\n]*/
%ignore /\/\*(.|\n)*?\*\//
