# CLI

NumFu provides a command-line interface for running programs, interactive development, and debugging. This reference covers all available commands and options.


-----
## Basic Usage

### Running Programs

The most common use case is running NumFu source files:

```bash
numfu myprogram.nfu
```

This executes the NumFu program in `myprogram.nfu` and displays the results.

-----
## Commands

### `numfu <file>` (Default Command)

**Description**: Parse and run a NumFu source file

**Usage**: `numfu [OPTIONS] SOURCE`

**Arguments**:
- `SOURCE`: Path to the NumFu source file (`.nfu` extension recommended, parsed binary `.nfut` files can also be run)

**Options**:
- `-p, --precision INTEGER`: Floating point precision for calculations (default: 15)
- `-r, --rec-depth INTEGER`: Maximum recursion depth during evaluation (default: 10000)
- `--iter-depth INTEGER`: Maximum iteration depth for tail-call optimization (default: infinite)

**Examples**:
```bash
# Run a program with default settings
numfu fibonacci.nfu

# Run with higher precision for mathematical computing
numfu -p 100 scientific_calculation.nfu

# Run with custom recursion limit
numfu -r 5000 recursive_algorithm.nfu

# Combine options
numfu -p 30 -r 15000 complex_program.nfu
```
-----
### `numfu parse`

**Description**: Parse and serialize input file or display its Abstract Syntax Tree

**Usage**: `numfu parse [OPTIONS] SOURCE`

**Arguments**:
- `SOURCE`: Path to the NumFu source file to parse

**Options**:
- `-p`: Pretty print the Abstract Syntax Tree (AST)
- `-o, --output PATH`: File name for the serialized source file (default: "SOURCE.nfut")
- `-m, --max-depth INTEGER`: Maximum AST depth to display (default: 10)
- `-n, --indent INTEGER`: Indentation size for pretty printing (default: 2)

**Examples**:
```bash
# Parse file and save to binary myprogram.nfut
numfu parse myprogram.nfu

# Save to custom file name
numfu parse -o source.nfut myprogram.nfu

# Customize display formatting
numfu parse -p -m 15 -n 4 myprogram.nfu
```

**AST Output Format**:
The AST is displayed as a hierarchical tree structure showing the parsed program structure:

```
[
  Call(
    func=Variable(name='println'),
    args=["Hello, World!"]
  )
]
```
-----
### `numfu repl`

**Description**: Start an interactive Read-Eval-Print Loop
**Usage**: `numfu repl [OPTIONS]`

**Options**:
- `-p, --precision INTEGER`: Floating point precision (default: 15)
- `-r, --rec-depth INTEGER`: Maximum recursion depth (default: 10000)
- `--iter-depth INTEGER`: Maximum iteration depth for tail-call optimization (default: infinite)

**Examples**:
```bash
# Start REPL with default settings
numfu repl

# Start with higher precision
numfu repl -p 50

# Start with custom recursion limit
numfu repl -r 5000
```

**REPL Features**:
- Interactive expression evaluation
- Persistent history (saved to `~/.numfu_history`)
- Multi-line input support (use `\` at end of line)
- Rich output formatting

**REPL Usage**:
```
NumFu REPL. Type 'exit' or press Ctrl+D to exit.
>>> 2 + 3 * 4
14
>>> let square = {x -> x * x} in \
... square(7)
49
>>> exit
```
-----
### `numfu repl ast`

**Description**: Start interactive AST exploration REPL â€” essentially interactive `numfu parse -p`

**Usage**: `numfu repl ast [OPTIONS]`

**Options**:
- `-m, --max-depth INTEGER`: Maximum AST depth to display (default: 10)
- `-n, --indent INTEGER`: Indentation size (default: 2)

**Examples**:
```bash
# Start AST REPL with default settings
numfu repl ast

# Customize AST display
numfu repl ast -m 15 -n 4
```

**AST REPL Usage**:
```
NumFu AST REPL. Type 'exit' or press Ctrl+D to exit.
>>> 2 + 3
[Import(name='builtins'), Call(func=Variable(name='+'), args=[2, 3])]
>>> {x -> x * x}
[
  Lambda(
    arg_names=['x'],
    body=Call(
      func=Variable(name='*'),
      args=[
        Variable(name='x'),
        Variable(name='x')
      ]
    )
  )
]
```

-----
## Global Options

### `--version`

Display NumFu version information.

### `--help`

Display help information for commands.

-----
## File Handling

### File Extensions

The `.nfu` extension should be used for standard NumFu source files and is supported by the module resolver.

The interpreter also recognizes binary, pre-parsed NumFu files, usually with the extension `.nfut`, which are generated by the `numfu parse` command. However, they cannot be imported as modules (though support is planned for future releases).


### Error Handling

NumFu provides detailed error messages with file context:

```bash
$ numfu broken_program.nfu
[at broken_program.nfu:5:15]
[5]   let l = [1,2,3 in f(...l)
                    ^
SyntaxError: Expected one of ',', ']'
```
